import sqlite3
import mapbox_vector_tile
import argparse
import os, gzip
from shapely import wkt
from shapely.geometry import Polygon, shape, mapping
from shapely.affinity import scale, translate
import mercantile
import json

def extend_geometry_to_extent(geometry_wkt, target_width, target_height):
    try:
        # Load geometry from WKT
        geom = wkt.loads(geometry_wkt)

        # Check if the geometry is valid
        if not geom.is_valid:
            print("Warning: Geometry is invalid.")
            return geometry_wkt

        # Convert the geometry to a GeoJSON-like dict
        geom_geojson = mapping(geom)

        # Get the bounding box of the geometry
        minx, miny, maxx, maxy = geom.bounds

        # Calculate scaling factors
        original_width = maxx - minx
        original_height = maxy - miny
        scale_x = target_width / original_width
        scale_y = target_height / original_height

        # Apply scaling and translation to fit within the target bounds
        scaled_geom = scale(geom, xfact=scale_x, yfact=scale_y, origin=(minx, miny))
        new_bounds = scaled_geom.bounds
        translate_x = 0 - new_bounds[0]
        translate_y = 0 - new_bounds[1]
        extended_geom = translate(scaled_geom, xoff=translate_x, yoff=translate_y)

        # Convert back to WKT
        return extended_geom.wkt

    except Exception as e:
        print(f"Error extending geometry: {e}")
        return geometry_wkt

def insert_tile(cursor, z, x, y, encoded_tile):
    cursor.execute("""
        INSERT INTO tiles (zoom_level, tile_column, tile_row, tile_data)
        VALUES (?, ?, ?, ?)
    """, (z, x, y, encoded_tile))

def create_mbtiles_file(mbtiles_path):
    if os.path.exists(mbtiles_path):
        print(f"MBTiles file '{mbtiles_path}' already exists.")
        return

    conn = sqlite3.connect(mbtiles_path)
    cursor = conn.cursor()

    # Create the necessary tables for MBTiles
    cursor.execute("""
        CREATE TABLE metadata (
            name TEXT,
            value TEXT
        )
    """)
    cursor.execute("""
        CREATE TABLE tiles (
            zoom_level INTEGER,
            tile_column INTEGER,
            tile_row INTEGER,
            tile_data BLOB
        )
    """)
    
    # Insert metadata
    cursor.execute("""
        INSERT INTO metadata (name, value)
        VALUES (?, ?)
    """, ('name', 'Example MBTiles'))
    cursor.execute("""
        INSERT INTO metadata (name, value)
        VALUES (?, ?)
    """, ('description', 'Generated by script'))
    cursor.execute("""
        INSERT INTO metadata (name, value)
        VALUES (?, ?)
    """, ('version', '1.0'))
    cursor.execute("""
        INSERT INTO metadata (name, value)
        VALUES (?, ?)
    """, ('format', 'pbf'))

    conn.commit()
    conn.close()

def main(mbtiles_path):
    # Create MBTiles file if it doesn't exist
    create_mbtiles_file(mbtiles_path)

    # Define the input JSON data
    data = [{
        "name": "water",
        "features": [{
            "geometry": "POLYGON((-16865170.021958850324154 14912715.209037467837334 , 14643411.096910387277603 14239454.928719751536846, 12085022.031703054904938 -9728611.050591036677361, -14441433.012815065681934 -10805827.499099388718605 , -16865170.021958850324154 14912715.209037467837334 ))",
            "properties": {"uid": 123, "foo": "bar", "cat": "flew"}
        }]
    }]
    # target_width = 4096
    # target_height = 4096

    # # Update geometries
    # for layer in data:
    #     for feature in layer["features"]:
    #         feature["geometry"] = extend_geometry_to_extent(feature["geometry"], target_width, target_height)

    print(data)
    # Encode the vector tile
    encoded_tile = mapbox_vector_tile.encode(data,extents=4096)
    print(encoded_tile)
    encoded_tile_gzipped = gzip.compress(encoded_tile)
    # Connect to the MBTiles file
    conn = sqlite3.connect(mbtiles_path)
    cursor = conn.cursor()

    # Insert the tile data into the tiles table
    # Assuming the tile coordinates are (z, x, y)
    z, x, y = 0, 0, 0  # Replace with actual zoom, column, and row values
    insert_tile(cursor, z, x, y, encoded_tile_gzipped)

    # Commit and close the connection
    conn.commit()
    conn.close()

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Create and insert a vector tile into an MBTiles file.')
    parser.add_argument('-o', '--output', required=True, help='Path to the MBTiles file')
    args = parser.parse_args()
    main(args.output)
